---
title: 'STATS 205: Final Project Write-Up'
author: "Brian Liu"
date: "6/14/2019"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 1. Background of the data and why it is interesting or important

>The data we are using is the data from WHO suicide statistics from Kaggle. This gives population-based statistics on suicide rate...

# 2. Explanation of the method studied and its properties

# 3. Data analysis or simulation study

We will use the crude rate of suicide per 100,000 people.

>This analysis provides information on age-standardized rates...

```{r}
who_suicide_statistics_df <- read.csv("who_suicide_statistics.csv")
head(who_suicide_statistics_df)
colnames(who_suicide_statistics_df)
```

>Filter and save countries with missing suicide rate.

<!-- install.packages("devtools", dependencies=TRUE, repos='http://cran.us.r-project.org') -->

```{r}
library(tidyverse)
filtered_suicide_df <- drop_na(who_suicide_statistics_df, "suicides_no")
head(filtered_suicide_df)
```

>After filtering countries with missing suicide rate, take a random sample of 100 countries and make sure each continent has approximately equal countries.

Filter countries by continent:


```{r}
library(countrycode)
filtered_suicide_df$continent <- countrycode(sourcevar = filtered_suicide_df[, "country"],
                            origin = "country.name",
                            destination = "continent")

head(filtered_suicide_df)
write.csv(filtered_suicide_df, 'filtered_suicide.csv')
```

Let us find out which continents are counted:

```{r}
# Get list of continents
list_of_continents <- unique(filtered_suicide_df$continent); list_of_continents
```

Therefore,

\[
	\frac{100 \textrm{ countries}}{6 \textrm{ continents}} \approx 16 \textrm{ to } 17 \textrm{ countries per continent}
\]

we should randomly sample 17 countries from each continent.


Notably, there are countries that are not on any of the listed continents. Let us see which ones those are:

```{r}
not_in_a_continent = filtered_suicide_df[is.na(filtered_suicide_df$continent),]
write.csv(not_in_a_continent, 'not_in_a_continent.csv')
head(not_in_a_continent)
unique(not_in_a_continent$country)
```

Let us make the choice not to include these countries in the analysis, since there are only two countries.


We will now create six dataframes, filtered by list of countries for each continent.

```{r}
# europe_suicide = filtered_suicide_df[filtered_suicide_df$continent == 'Europe',]
# head(europe_suicide)
# length(europe_suicide$country)
# americas_suicide = filtered_suicide_df[filtered_suicide_df$continent == 'Americas',]
# head(americas_suicide)
# length(americas_suicide$country)
# asia_suicide = filtered_suicide_df[filtered_suicide_df$continent == 'Asia',]
# head(asia_suicide)
# length(asia_suicide$country)
# oceania_suicide = filtered_suicide_df[filtered_suicide_df$continent == 'Oceania',]
# head(oceania_suicide)
# length(oceania_suicide$country)
africa_suicide = filtered_suicide_df[filtered_suicide_df$continent == 'Africa',]
head(africa_suicide)
length(africa_suicide$country)
library(rlist)
countries_per_continent <- list()
length(list_of_continents)
list_of_continents
# does this work?
continent_eur <- filtered_suicide_df[filtered_suicide_df$continent == 'Europe',]
    head(continent_eur)
# ^ It seems to work! How about this?
stringerino <- "Europe"
asdfg <- filtered_suicide_df[filtered_suicide_df$continent == stringerino,]
head(asdfg)

for (i in seq_along(list_of_continents))
{
	countries_per_continent[[i]] <- filtered_suicide_df[filtered_suicide_df$continent == list_of_continents[i],]
}

length(countries_per_continent)

length(countries_per_continent)

for (i in seq_along(countries_per_continent))
{
	print(head(countries_per_continent[[i]]))
	cat("\n")
}
```

[This text links to very important information about why a `for` loop doesn't print anything.](https://stackoverflow.com/questions/14987743/head-function-does-not-work-within-for-loop) 

Basically, `for` loops are functions themselves. Since R prints out the result of a command automatically, but functions are not a command, you need to have `print(command())` in order to get output.

# 4. Interpretation of the results or discussion
